{
if (verbose==TRUE) { cat(sprintf("nulrep%d ",i)) }
nulls[[i]] <- generate_nul_resample(nul, obs)
}
if (verbose==TRUE) { cat('...done.\n') }
if (plot==TRUE)
{
plot_netassoc_matrix(nulls[[sample(numnulls, 1)]], colors=colorRampPalette(c('white','black'))(51),onesided=TRUE,main="Example null resample sp x site")
}
fm_obs <- matrix(NA,nrow=nrow(obs),ncol=nrow(obs))
fm_nul_mean <- matrix(NA,nrow=nrow(obs),ncol=nrow(obs))
fm_nul_sd <- matrix(NA,nrow=nrow(obs),ncol=nrow(obs))
finalmatrix <- matrix(NA,nrow=nrow(obs),ncol=nrow(obs))
if (verbose==TRUE) { cat('Calculating co-occurrence scores...') }
count <- 0
for (i in 1:nrow(obs))
{
for (j in i:nrow(obs))
{
if (i!=j)
{
count <- count + 1
if (verbose==TRUE) { cat (sprintf('%d %d %.3f ', i, j, count/(nrow(obs)*(nrow(obs)-1)/2))) }
if (verbose==TRUE) { cat('obs') }
cor_obs <- spcor(inputmatrix=obs, i, j, inputmethod=whichmethod)
if (verbose==TRUE) { cat('. ') }
fm_obs[i,j] <- cor_obs
if (!is.na(cor_obs))
{
cor_nul <- rep(NA, numnulls)
for (k in 1:numnulls)
{
if (verbose==TRUE) { cat(sprintf('nul%d',k)) }
cor_nul[k] <- spcor(inputmatrix=nulls[[k]], i, j, inputmethod=whichmethod)
if (verbose==TRUE) { cat('. ') }
}
fm_nul_mean[i,j] <- mean(cor_nul,na.rm=T)
fm_nul_sd[i,j] <- sd(cor_nul,na.rm=T)
}
else
{
if (verbose==TRUE) { cat('nul NONE') }
}
if (verbose==TRUE) { cat('\n') }
}
}
}
if (verbose==TRUE) { cat('...done.\n') }
# calculate standard effect size
if (verbose==TRUE) { cat('Calculating standardized effect sizes...') }
finalmatrix <- (fm_obs - fm_nul_mean) / fm_nul_sd
if (verbose==TRUE) { cat('...done.\n') }
if (plot==TRUE)
{
plot_netassoc_matrix(fm_obs, xlab='Species',ylab='Species',colors=colorRampPalette(c('red','white','blue'))(51),main="Observed co-occurrence score for sp x sp")
plot_netassoc_matrix(fm_nul_mean, xlab='Species',ylab='Species',colors=colorRampPalette(c('red','white','blue'))(51),main="Null mean co-occurrence score for sp x sp")
plot_netassoc_matrix(fm_nul_sd,   xlab='Species',ylab='Species',colors=colorRampPalette(c('white','gray'))(51),onesided=TRUE,main="Null s.d. co-occurrence score for sp x sp")
}
dimnames(finalmatrix) <- list(row.names(obs),row.names(obs))
# trim out low-value nodes
if (verbose==TRUE) { cat('Applying kappa threshold...') }
finalmatrix_trimmed <- finalmatrix
finalmatrix_trimmed[abs(finalmatrix_trimmed) < kappa] <- 0
finalmatrix_trimmed[is.na(finalmatrix_trimmed)] <- 0
finalmatrix_trimmed[is.infinite(finalmatrix_trimmed)] <- 0
if (verbose==TRUE) { cat('...done.\n') }
if (plot==TRUE)
{
plot_netassoc_matrix(finalmatrix_trimmed, xlab='Species',ylab='Species',colorRampPalette(c('red','white','blue'))(51),main="S.E.S. co-occurrence score for sp x sp")
}
# convert to network representation
if (verbose==TRUE) { cat('Building network...') }
network_all <- graph.adjacency(finalmatrix_trimmed,mode='upper',weighted=T)
if (verbose==TRUE) { cat('...done.\n') }
if (plot==TRUE)
{
plot_netassoc_network(network_all)
title('Association network')
}
if (plot==TRUE)
{
par(mfrow=c(1,1))
}
return(list(
matrix_spsite_obs=obs,
matrix_spsite_null=nul,
matrix_spsite_nulls=nulls,
matrix_spsp_obs=fm_obs,
matrix_spsp_null_mean=fm_nul_mean,
matrix_spsp_null_sd=fm_nul_sd,
matrix_spsp_ses_all=finalmatrix,
matrix_spsp_ses_thresholded=finalmatrix_trimmed,
network_all=network_all
))
}
# plot network
plot_netassoc_network <- function(network, layout = layout.auto(network),
vertex.label = V(network)$name,
vertex.color = NA,
vertex.shape = "none",
vertex.label.color = "black",
vertex.label.family = "sans",
edge.width = NULL,
edge.color = NULL,
edge.arrow.size = 0.05,
vertex.label.cex = 0.5,
...)
{
if(is.null(edge.width))
{
if(length(E(network)$weight)==0)
{
edge.width=1
}
else
{
edge.width=sqrt(abs(E(network)$weight))
}
}
if(is.null(edge.color))
{
if(length(E(network)$weight)==0)
{
edge.color <- 'black'
zlmin <- -1
zlmax <- 1
}
else
{
edge.color <- ifelse(E(network)$weight > 0, rgb(0,0,1,0.8),rgb(1,0,0,0.8))
zlmax <- max(abs(E(network)$weight),na.rm=T)
zlmin = -1*zlmax
}
}
plot(network,
layout=layout,
vertex.label=vertex.label,
edge.color=edge.color,
edge.width=edge.width,
vertex.color=vertex.color,
vertex.label.color=vertex.label.color,
vertex.shape=vertex.shape,
edge.arrow.size=edge.arrow.size,
vertex.label.cex=vertex.label.cex,
vertex.label.family=vertex.label.family,
...)
colors=colorRampPalette(c('red','white','blue'))(51)
legend('topleft',adj=c(0,0),legend=format(c(zlmin,zlmin/2+zlmax/2,zlmax),digits=2),fill=c(colors[1],colors[ceiling(length(colors)/2)],colors[length(colors)]),bg='white',cex=0.5)
}
plot_netassoc_matrix <- function(data, colors, ylab='Species',xlab='Site',onesided=FALSE,main="")
{
zlmax <- max(abs(as.numeric(data)),na.rm=T)
if (is.infinite(zlmax))
{
zlmax <- 1
}
if (onesided==TRUE)
{
zlmin = 0
}
else
{
zlmin = -1*zlmax
}
image(t(data),col=colors,axes=F,zlim=c(zlmin, zlmax),main=main)
mtext(side=2,text=ylab,cex=0.5)
mtext(side=3,text=xlab,cex=0.5)
legend('topleft',adj=c(0,0),legend=format(c(zlmin,zlmin/2+zlmax/2,zlmax),digits=2),fill=c(colors[1],colors[ceiling(length(colors)/2)],colors[length(colors)]),bg='white',cex=0.5)
box()
}
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
zmaxent <- readRDS('expected_abund_Feb2015_bio.rdata')
zobs <- readRDS('observed_abund_for_sdm.rdata')
rn <- intersect(intersect(rownames(zmaxent), rownames(zloess)),rownames(zobs))
cn <- intersect(intersect(colnames(zmaxent), colnames(zloess)), colnames(zobs))
dropcols1 <- union(union(names(which(is.na(colSums(zloess)))),names(which(is.na(colSums(zmaxent))))),names(which(is.na(colSums(zobs)))))
dropcols <- unique(c(dropcols1, names(which(colSums(zobs)==0)), names(which(colSums(zmaxent)==0)), names(which(colSums(zloess)==0))))
droprows <- unique(c(names(which(is.infinite(rowSums(zmaxent)))), names(which(rowSums(zobs)==0)), names(which(rowSums(zmaxent)==0)), names(which(rowSums(zloess)==0))))
cn_trimmed <- setdiff(cn, dropcols)
rn_trimmed <- setdiff(rn, droprows)
zmaxent_trimmed <- zmaxent[rn_trimmed, cn_trimmed]
zloess_trimmed <- zloess[rn_trimmed, cn_trimmed]
zobs_trimmed <- zobs[rn_trimmed, cn_trimmed]
# make sure all matrices have same dimensions
stopifnot(all(apply(sapply(list(zloess_trimmed, zmaxent_trimmed, zobs_trimmed),dim),1,sd)==0))
saveRDS(zloess_trimmed, file='input_nul_loess.Rdata')
saveRDS(zmaxent_trimmed, file='input_nul_maxent.Rdata')
saveRDS(zobs_trimmed, file='input_obs.Rdata')
inputs <-
expand.grid(
kappa=c(2,3),
method=c("pearson","spearman"),
obsname='input_obs.Rdata',
nulname=c('input_nul_loess.Rdata','input_nul_maxent.Rdata'),
nnulls=c(100),
stringsAsFactors=F)
ilist <- vector("list",nrow(inputs))
for (i in 1:nrow(inputs))
{
ilist[[i]] <- data.frame(inputs[i,])
}
library(netassoc)
library(parallel)
set.seed(42) # choose RNG seed
#n.cores = 16
n.cores=1
options(error=recover)
allr <- mclapply(ilist, mc.set.seed=FALSE, mc.cores=n.cores, FUN=function(x)
{
x <- as.vector(x)
of <- paste(c('out',x[1,"obsname"], x[1,"nulname"], x[1,"method"], x[1,"kappa"],x[1,"nnulls"]),collapse="_")
print(of)
net <- makenetwork(
obs=readRDS(x[1,"obsname"]),
nul=readRDS(x[1,"nulname"]),
whichmethod=x[1,"method"],
kappa=x[1,"kappa"],
numnulls=x[1,"nnulls"],
plot=FALSE,
verbose=TRUE
)
saveRDS(object=net, file=sprintf("%s.rdata",of))
return(net)
}
)
library(netassoc)
setwd("~/Documents/BIEN projects/coexistence networks/Mar2015")
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
zmaxent <- readRDS('expected_abund_Feb2015_bio.rdata')
zobs <- readRDS('observed_abund_for_sdm.rdata')
rn <- intersect(intersect(rownames(zmaxent), rownames(zloess)),rownames(zobs))
cn <- intersect(intersect(colnames(zmaxent), colnames(zloess)), colnames(zobs))
dropcols1 <- union(union(names(which(is.na(colSums(zloess)))),names(which(is.na(colSums(zmaxent))))),names(which(is.na(colSums(zobs)))))
dropcols <- unique(c(dropcols1, names(which(colSums(zobs)==0)), names(which(colSums(zmaxent)==0)), names(which(colSums(zloess)==0))))
droprows <- unique(c(names(which(is.infinite(rowSums(zmaxent)))), names(which(rowSums(zobs)==0)), names(which(rowSums(zmaxent)==0)), names(which(rowSums(zloess)==0))))
cn_trimmed <- setdiff(cn, dropcols)
rn_trimmed <- setdiff(rn, droprows)
zmaxent_trimmed <- zmaxent[rn_trimmed, cn_trimmed]
zloess_trimmed <- zloess[rn_trimmed, cn_trimmed]
zobs_trimmed <- zobs[rn_trimmed, cn_trimmed]
# make sure all matrices have same dimensions
stopifnot(all(apply(sapply(list(zloess_trimmed, zmaxent_trimmed, zobs_trimmed),dim),1,sd)==0))
saveRDS(zloess_trimmed, file='input_nul_loess.Rdata')
saveRDS(zmaxent_trimmed, file='input_nul_maxent.Rdata')
saveRDS(zobs_trimmed, file='input_obs.Rdata')
inputs <-
expand.grid(
kappa=c(2,3),
method=c("pearson","spearman"),
obsname='input_obs.Rdata',
nulname=c('input_nul_loess.Rdata','input_nul_maxent.Rdata'),
nnulls=c(100),
stringsAsFactors=F)
ilist <- vector("list",nrow(inputs))
for (i in 1:nrow(inputs))
{
ilist[[i]] <- data.frame(inputs[i,])
}
library(netassoc)
library(parallel)
set.seed(42) # choose RNG seed
#n.cores = 16
n.cores=1
options(error=recover)
allr <- mclapply(ilist, mc.set.seed=FALSE, mc.cores=n.cores, FUN=function(x)
{
x <- as.vector(x)
of <- paste(c('out',x[1,"obsname"], x[1,"nulname"], x[1,"method"], x[1,"kappa"],x[1,"nnulls"]),collapse="_")
print(of)
net <- makenetwork(
obs=readRDS(x[1,"obsname"]),
nul=readRDS(x[1,"nulname"]),
whichmethod=x[1,"method"],
kappa=x[1,"kappa"],
numnulls=x[1,"nnulls"],
plot=FALSE,
verbose=TRUE
)
saveRDS(object=net, file=sprintf("%s.rdata",of))
return(net)
}
)
library(netassoc)
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
zmaxent <- readRDS('expected_abund_Feb2015_bio.rdata')
zobs <- readRDS('observed_abund_for_sdm.rdata')
rn <- intersect(intersect(rownames(zmaxent), rownames(zloess)),rownames(zobs))
cn <- intersect(intersect(colnames(zmaxent), colnames(zloess)), colnames(zobs))
dropcols1 <- union(union(names(which(is.na(colSums(zloess)))),names(which(is.na(colSums(zmaxent))))),names(which(is.na(colSums(zobs)))))
dropcols <- unique(c(dropcols1, names(which(colSums(zobs)==0)), names(which(colSums(zmaxent)==0)), names(which(colSums(zloess)==0))))
droprows <- unique(c(names(which(is.infinite(rowSums(zmaxent)))), names(which(rowSums(zobs)==0)), names(which(rowSums(zmaxent)==0)), names(which(rowSums(zloess)==0))))
cn_trimmed <- setdiff(cn, dropcols)
rn_trimmed <- setdiff(rn, droprows)
zmaxent_trimmed <- zmaxent[rn_trimmed, cn_trimmed]
zloess_trimmed <- zloess[rn_trimmed, cn_trimmed]
zobs_trimmed <- zobs[rn_trimmed, cn_trimmed]
# make sure all matrices have same dimensions
stopifnot(all(apply(sapply(list(zloess_trimmed, zmaxent_trimmed, zobs_trimmed),dim),1,sd)==0))
saveRDS(zloess_trimmed, file='input_nul_loess.Rdata')
saveRDS(zmaxent_trimmed, file='input_nul_maxent.Rdata')
saveRDS(zobs_trimmed, file='input_obs.Rdata')
inputs <-
expand.grid(
kappa=c(2,3),
method=c("pearson","spearman"),
obsname='input_obs.Rdata',
nulname=c('input_nul_loess.Rdata','input_nul_maxent.Rdata'),
nnulls=c(1000),
stringsAsFactors=F)
ilist <- vector("list",nrow(inputs))
for (i in 1:nrow(inputs))
{
ilist[[i]] <- data.frame(inputs[i,])
}
library(netassoc)
library(parallel)
set.seed(1) # choose RNG seed
#n.cores = 16
n.cores=1
options(error=recover)
allr <- mclapply(ilist, mc.set.seed=FALSE, mc.cores=n.cores, FUN=function(x)
{
x <- as.vector(x)
of <- paste(c('out',x[1,"obsname"], x[1,"nulname"], x[1,"method"], x[1,"kappa"],x[1,"nnulls"]),collapse="_")
print(of)
net <- makenetwork(
obs=readRDS(x[1,"obsname"]),
nul=readRDS(x[1,"nulname"]),
whichmethod=x[1,"method"],
kappa=x[1,"kappa"],
numnulls=x[1,"nnulls"],
plot=FALSE,
verbose=TRUE
)
saveRDS(object=net, file=sprintf("%s.rdata",of))
return(net)
}
)
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
0
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
setwd("~/Documents/BIEN projects/coexistence networks/Mar2015")
# convert other input
zloess <- readRDS('pss_loess_24.02.2015.rdata')
zmaxent <- readRDS('expected_abund_Feb2015_bio.rdata')
zobs <- readRDS('observed_abund_for_sdm.rdata')
rn <- intersect(intersect(rownames(zmaxent), rownames(zloess)),rownames(zobs))
cn <- intersect(intersect(colnames(zmaxent), colnames(zloess)), colnames(zobs))
dropcols1 <- union(union(names(which(is.na(colSums(zloess)))),names(which(is.na(colSums(zmaxent))))),names(which(is.na(colSums(zobs)))))
dropcols <- unique(c(dropcols1, names(which(colSums(zobs)==0)), names(which(colSums(zmaxent)==0)), names(which(colSums(zloess)==0))))
droprows <- unique(c(names(which(is.infinite(rowSums(zmaxent)))), names(which(rowSums(zobs)==0)), names(which(rowSums(zmaxent)==0)), names(which(rowSums(zloess)==0))))
cn_trimmed <- setdiff(cn, dropcols)
rn_trimmed <- setdiff(rn, droprows)
zmaxent_trimmed <- zmaxent[rn_trimmed, cn_trimmed]
zloess_trimmed <- zloess[rn_trimmed, cn_trimmed]
zobs_trimmed <- zobs[rn_trimmed, cn_trimmed]
# make sure all matrices have same dimensions
stopifnot(all(apply(sapply(list(zloess_trimmed, zmaxent_trimmed, zobs_trimmed),dim),1,sd)==0))
saveRDS(zloess_trimmed, file='input_nul_loess.Rdata')
saveRDS(zmaxent_trimmed, file='input_nul_maxent.Rdata')
saveRDS(zobs_trimmed, file='input_obs.Rdata')
inputs <-
expand.grid(
kappa=c(2,3),
method=c("pearson","spearman"),
obsname='input_obs.Rdata',
nulname=c('input_nul_loess.Rdata','input_nul_maxent.Rdata'),
nnulls=c(1000),
stringsAsFactors=F)
ilist <- vector("list",nrow(inputs))
for (i in 1:nrow(inputs))
{
ilist[[i]] <- data.frame(inputs[i,])
}
library(netassoc)
library(parallel)
set.seed(1) # choose RNG seed
#n.cores = 16
n.cores=1
options(error=recover)
allr <- mclapply(ilist, mc.set.seed=FALSE, mc.cores=n.cores, FUN=function(x)
{
x <- as.vector(x)
of <- paste(c('out',x[1,"obsname"], x[1,"nulname"], x[1,"method"], x[1,"kappa"],x[1,"nnulls"]),collapse="_")
print(of)
net <- makenetwork(
obs=readRDS(x[1,"obsname"]),
nul=readRDS(x[1,"nulname"]),
whichmethod=x[1,"method"],
kappa=x[1,"kappa"],
numnulls=x[1,"nnulls"],
plot=FALSE,
verbose=TRUE
)
saveRDS(object=net, file=sprintf("%s.rdata",of))
return(net)
}
)
ls
library(netassoc)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
?replicate
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
library(netassoc)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
debug(generate_nul_resample)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
n
debug(makenetwork)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
nul
dimnames(nul)
nrow(nul)
samples <- sample(1:nrow(nul),size=sum(obs[,i]),replace=TRUE,prob=nul[,i])
samples
tabulate(samples)
?tabulate
tabulate(samples, nbins=nrow(nul))
samples <- sample(1:nrow(nul),size=sum(obs[,i]),replace=TRUE,prob=nul[,i])
nul_resample[,i] <- tabulate(samples, nbins=nrow(nul))
nul_resample
nul_resample <- 0
nul_resample
nul_resample <- matrix(0, nrow=nrow(nul),ncol=ncol(nul),dimnames=dimnames(nul))
for (i in 1:ncol(nul_resample))
{
# fill in resamples with the same total abundance
samples <- sample(1:nrow(nul),size=sum(obs[,i]),replace=TRUE,prob=nul[,i])
nul_resample[,i] <- tabulate(samples, nbins=nrow(nul))
}
nul_reasample
nul_resample
q()
q
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
n
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
n
apply(n, 3, colSums)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
library(netassoc)
set.seed(1)
nsp <- 10
nsi <- 5
m_obs <- floor(matrix(rgamma(nsp*nsi,shape=5),ncol=nsi,nrow=nsp))
m_nul <- floor(matrix(rexp(nsp*nsi,rate=0.05),ncol=nsi,nrow=nsp))
n <- makenetwork(m_obs, m_nul, numnulls=50, plot=TRUE)
library(netassoc)
